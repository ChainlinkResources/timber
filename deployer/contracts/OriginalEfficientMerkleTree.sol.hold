pragma solidity >=0.4.21 <0.6.0;

contract OriginalEfficientMerkleTree {

    event Hash(bytes32 hash, uint row);
    event Inputs(bytes32 left, bytes32 right);

    /** NEW LOGIC*/

    uint merkleDepth = 33;
    uint merkleWidth = 4294967296; // 2^32
    bytes32[33] merkleStack;
    bytes32 zero = 0x0000000000000000000000000000000000000000000000000000000000000000;

    function checkZero() public view returns (bool) {
        return zero == M[100];
    }

    function getSlot(uint leafIndex) public pure returns (uint slot) {
        slot = 0;
        if ( leafIndex % 2 == 0 ) {
            uint k = 2;
            uint pow1 = 2;
            uint pow2 = pow1 * 2;
            while (slot == 0) {
                if ( (leafIndex - pow1) % pow2 == 0 ) {
                    slot = k;
                } else {
                    pow1 = pow2;
                    pow2 *= 2;
                    k++;
                }
            }
        } else {
            slot = 1;
        }
    }


    function hash() public pure returns (bytes32 h) {
        bytes memory a = "0x1234";
        h = sha256(a);
    }

    function encode() public pure returns (bytes memory) {
        uint256 input = 673203127856521342257374020331322469077963131917;
        return abi.encodePacked(input);
    }

    function assemblyHash() public returns (bytes32[1] memory h) {
        bytes32[2] memory inputs;
        inputs[0] = "0x1234";
        inputs[1] = "0x5678";
        bool success;
        assembly {
            /*
                gasLimit: calling with gas equal to not(0), as we have here, will send all available gas to the function being called. This removes the need to guess or upper-bound the amount of gas being sent yourself. As an alternative, we could have guessed the gas needed: with: sub(gas, 2000)
                to: the sha256 precompile is at address 0x2: Sending the amount of gas currently available to us, after subtracting 2000;
                value: 0 (no ether will be sent to the contract)
                inputOffset: I believe this is just the input data
                inputSize: hex input size = 0x40 = 2 x 32-bytes
                outputOffset: where will the output be stored (in variable h in our case)
                outputSize: sha256 outputs 256-bits = 32-bytes = 0x20 in hex
            */
            success := call(not(0), 2, 0, inputs, 0x40, h, 0x20)
            // Use "invalid" to make gas estimation work
            switch success case 0 { invalid() }
        }
    }

    /// @return the sum of two points of G1
    function addition(uint x1, uint y1, uint x2, uint y2) public returns (uint[2] memory p) {
        uint[4] memory input;
        input[0] = x1;
        input[1] = y1;
        input[2] = x2;
        input[3] = y2;
        bool success;
        assembly {
            success := call(sub(gas, 2000), 6, 0, input, 0xc0, p, 0x60)
            // Use "invalid" to make gas estimation work
            switch success case 0 { invalid() }
        }
        require(success, "EC addition failed");
    }

    // /// @return the product of a point on G1 and a scalar, i.e.
    // /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.
    // function scalar_mul(Points.G1Point memory p, uint s) internal returns (Points.G1Point memory r) {
    //     uint[3] memory input;
    //     input[0] = p.X;
    //     input[1] = p.Y;
    //     input[2] = s;
    //     bool success;
    //     assembly {
    //         success := call(sub(gas, 2000), 7, 0, input, 0x80, r, 0x60)
    //         // Use "invalid" to make gas estimation work
    //         switch success case 0 { invalid() }
    //     }
    //     require (success, "EC scalar multiplication failed");
    // }


    /**
    Updates each node of the Merkle Tree on the path from leaf to root.
    p - is the leafIndex of the new token within M.
    z - is the commitment
    */
    function assemblyUpdatePathToRoot(uint leafIndex) public returns (bytes32) {

    /*
    If Z were the token, then the p's mark the 'path', and the s's mark the 'sibling path'
                     p
            p                  s
       s         p        EF        GH
    A    B    Z    s    E    F    G    H
    */
        bytes32 z = "0x1234";
        uint slot = getSlot(leafIndex);
        uint p = leafIndex + merkleWidth - 2; // p is the position in all nodes
        bytes32 h = z; // h is the hash, which repeatedly gets overridden to the top of the tree until it becomes the root.
        // emit Hash(h, merkleDepth);
        bytes32[2] memory inputs;
        bytes32[1] memory output;
        bool success;

        uint t; //temp index for the next p (i.e. the path node of the row above)
        for (uint r = 1; r < merkleDepth; r++) {

            if (r == slot) merkleStack[slot] = h;

            if (p%2 == 0) { // p even index
                t = (p-1)/2;
                // emit Inputs(merkleStack[r],h);
                inputs[0] = merkleStack[r];
                inputs[1] = h;
                assembly {
                    /*
                        gasLimit: calling with gas equal to not(0), as we have here, will send all available gas to the function being called. This removes the need to guess or upper-bound the amount of gas being sent yourself. As an alternative, we could have guessed the gas needed: with: sub(gas, 2000)
                        to: the sha256 precompile is at address 0x2: Sending the amount of gas currently available to us, after subtracting 2000;
                        value: 0 (no ether will be sent to the contract)
                        inputOffset: I believe this is just the input data
                        inputSize: hex input size = 0x20 = 32-bytes = 256-bits
                        outputOffset: where will the output be stored (in variable h in our case)
                        outputSize: sha256 outputs 256-bits = 32-bytes = 0x20 in hex
                    */
                    success := call(not(0), 2, 0, inputs, 0x40, output, 0x20)
                    // Use "invalid" to make gas estimation work
                    switch success case 0 { invalid() }
                }
                h = output[0];
                //h = bytes32(sha256(abi.encodePacked(merkleStack[r],h)));
                // emit Hash(h, r);
            } else { // p odd index
                t = p/2;
                inputs[0] = h;
                inputs[1] = zero;
                assembly {
                    /*
                        gasLimit: calling with gas equal to not(0), as we have here, will send all available gas to the function being called. This removes the need to guess or upper-bound the amount of gas being sent yourself. As an alternative, we could have guessed the gas needed: with: sub(gas, 2000)
                        to: the sha256 precompile is at address 0x2: Sending the amount of gas currently available to us, after subtracting 2000;
                        value: 0 (no ether will be sent to the contract)
                        inputOffset: I believe this is just the input data
                        inputSize: hex input size = 0x20 = 32-bytes = 256-bits
                        outputOffset: where will the output be stored (in variable h in our case)
                        outputSize: sha256 outputs 256-bits = 32-bytes = 0x20 in hex
                    */
                    success := call(not(0), 2, 0, inputs, 0x40, output, 0x20)
                    // Use "invalid" to make gas estimation work
                    switch success case 0 { invalid() }
                }
                h = output[0];
                // emit Inputs(h,zero);
                // h = bytes32(sha256(abi.encodePacked(h, zero)));
                // emit Hash(h, r);
            }
            p = t; //move to the path node on the next highest row of the tree
        }

        // gas refund:
        if (slot > 1) merkleStack[slot - 1] = 0;

        return h; //the root of M
    }


        /**
    Updates each node of the Merkle Tree on the path from leaf to root.
    p - is the leafIndex of the new token within M.
    z - is the commitment
    */
    function updatePathToRoot(uint leafIndex) public returns (bytes32) {

    /*
    If Z were the token, then the p's mark the 'path', and the s's mark the 'sibling path'
                     p
            p                  s
       s         p        EF        GH
    A    B    Z    s    E    F    G    H
    */
        bytes32 z = "0x1234";
        uint slot = getSlot(leafIndex);
        uint p = leafIndex + merkleWidth - 2; // p is the position in all nodes
        bytes32 h = z; // h is the hash, which repeatedly gets overridden to the top of the tree until it becomes the root.
        // emit Hash(h, merkleDepth);

        uint t; //temp index for the next p (i.e. the path node of the row above)
        for (uint r = 1; r < merkleDepth; r++) {

            if (r == slot) merkleStack[slot] = h;

            if (p%2 == 0) { // p even index
                t = (p-1)/2;
                // emit Inputs(merkleStack[r],h);
                h = bytes32(sha256(abi.encodePacked(merkleStack[r],h)));
                // emit Hash(h, r);
            } else { // p odd index
                t = p/2;
                // emit Inputs(h,zero);
                h = bytes32(sha256(abi.encodePacked(h, zero)));
                // emit Hash(h, r);
            }
            p = t; //move to the path node on the next highest row of the tree
        }

        return h; //the root of M
    }


    /** OLD LOGIC*/

    mapping(uint => bytes32) public M;

    /**
    Updates each node of the Merkle Tree on the path from leaf to root.
    leafIndex - is the leafIndex of the new token within THE BOTTOM ROW OF M
    */
    function oldUpdatePathToRootOld(uint leafIndex) public returns (bytes32) {

    /*
    If Z were the token, then the p's mark the 'path', and the s's mark the 'sibling path'
                     p
            p                  s
       s         p        EF        GH
    A    B    Z    s    E    F    G    H
    */
        uint p = leafIndex + merkleWidth - 2; // p is the position in all nodes
        bytes32 z = "0x1234";
        M[p] = z;
        // emit Hash(M[p], merkleDepth);

        uint s; //s is the 'sister' path of p.
        uint t; //temp index for the next p (i.e. the path node of the row above)
        for (uint r = merkleDepth-1; r > 0; r--) {
            if (p%2 == 0) { //p even index in M
                s = p-1;
                t = (p-1)/2;
                // emit Inputs(M[s],M[p]);
                M[t] = bytes32(sha256(abi.encodePacked(M[s],M[p])));
                // emit Hash(M[t], r);
            } else { //p odd index in M
                s = p+1;
                t = p/2;
                // emit Inputs(M[p],M[s]);
                M[t] = bytes32(sha256(abi.encodePacked(M[p],M[s])));
                // emit Hash(M[t], r);
            }
            p = t; //move to the path node on the next highest row of the tree
        }
        return M[0]; //the root of M
    }




    function loggy(uint x) public pure returns (uint y){
       assembly {
            let arg := x
            x := sub(x,1)
            x := or(x, div(x, 0x02))
            x := or(x, div(x, 0x04))
            x := or(x, div(x, 0x10))
            x := or(x, div(x, 0x100))
            x := or(x, div(x, 0x10000))
            x := or(x, div(x, 0x100000000))
            x := or(x, div(x, 0x10000000000000000))
            x := or(x, div(x, 0x100000000000000000000000000000000))
            x := add(x, 1)
            let m := mload(0x40)
            mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)
            mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)
            mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)
            mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)
            mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)
            mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)
            mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)
            mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)
            mstore(0x40, add(m, 0x100))
            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff
            let shift := 0x100000000000000000000000000000000000000000000000000000000000000
            let a := div(mul(x, magic), shift)
            y := div(mload(add(m,sub(255,a))), shift)
            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))
        }
    }
}
